function void boot_printout(int type, int n, int rep,
                            int failed, const matrix Spar_mat)

    matrix bm = meanc(Spar_mat)
    matrix bV = mcov(Spar_mat)
    scalar nc = cols(Spar_mat)
    scalar n2 = n*n

    # force numerical zeros to real zeros
    e = diag(bV) .< 1.0e-12
    if maxc(e)
        e = selifc(seq(1, nc), e')
        bV[e,] = 0
        bV[,e] = 0
    endif

    printf "Bootstrap results (%d replications, %d failed)\n", \
      rep + failed, failed

    if (type != 3) && ( cols(Spar_mat) == 2 * n2 )
        # Long-run matrix at the end exists!
        # And so this is a model with long-run restrictions
        # (Bl-Quah-style or SVEC),
        # or the user forced it via calc_lr.

        matrix bK = mshape( bm[1:n2], n, n)
        printStrMat(bK, bV[1:n2, 1:n2], "C")
        matrix bL = mshape( bm[n2+1:], n, n)
        printStrMat(bL, bV[1+n2: , 1+n2: ], "LongRun")

    elif type != 3 #  was: (type == 1) || (type == 2) || (type == 4)

        # C model without printing the long-run matrix
        # (SVEC / type 4 should not happen here, because it has long-run
        #  constraints by construction)

        matrix bK = mshape(bm,n,n)
        printStrMat(bK, bV, "C")

    elif type == 3	# AB model
        matrix bmA = mshape( bm[1:n2], n, n)
        printStrMat(bmA, bV[1:n2, 1:n2], "A")
        matrix bmB = mshape( bm[n2+1:], n, n)
        printStrMat(bmB, bV[1+n2:,1+n2:], "B")

    else
        funcerr "shouldn't happen"
    endif
end function

###############

function matrix bias_correction(const bundle bobj, const matrix bmu,
                                matrix *BC)

    /* This function implements a bias correction for
       the estimate of the VAR parameters as per Kilian,
       REStat (1998).
       (The SVEC case is not allowed here, but it must
       be checked on the outside.)

       New 'boottype' arg (Aug 2019):
       1: standard resampling (default, as before)
       2-4: wild bootstrap (3 variants)
       (It's not ideal to have 8 arguments in this function,
       but this is the least invasive way to do it now...)

       New again Sep 2019: revamp the whole thing to accept the
       model bundle as an arg to replace almost everything!

       (The innovations bobj.innov are assumed to be already
       processed, e.g. recentered, depending on boottype.)
    */

    # Copy stuff
    H = bobj.BCiter
    matrix Ahat = bobj.VARpar
    matrix E = bobj.E
    matrix X = bobj.X
    matrix Y0 = bobj.Y[1: bobj.p, ] # starting values
    boottype = bobj.boottype

    n = rows(Ahat)
    p = cols(Ahat)/n
    k = cols(X)
    cmu = cols(bmu)
    rY0 = rows(Y0)

    # check for stationarity first
    scalar maxmod = max_eval(Ahat)

    if maxmod < 0.9999
        matrix Ab = zeros(n, n*p)

        loop i=1..H --quiet
            matrix U = zeros(p,n) | drawbootres(bobj.innov, boottype)

            if cmu > 0
                U = bmu + U
            endif
            matrix bY = varsimul(Ahat, U[rY0+1:,], Y0)
            matrix reg  = X ~ mlag(bY, seq(1,p))
            matrix Pi = mols(bY[p+1:,], reg[p+1:,])
            matrix Ab += transp(Pi[k+1:k+n*p,])
        endloop

        Ab = Ab ./ H
        matrix BC = Ahat - Ab

        H = add_and_smash(&Ab, BC)

    else	# not stationary
        matrix Ab = Ahat
    endif
    return Ab
end function


function matrix calc_bmu(const bundle obj)
/* Disentangle determ/exog
   (Sven:) -- not entirely clear why this functionality would
   be specific	to the bootstrap?
   -> Perhaps a similar function or code block is
   lurking around somewhere else!
    */

    matrix bmu = zeros(obj.T, obj.n)
    if obj.k && obj.type == 4 # SVEC,
        # (with some unrestr. exo apart from const/trend)
        if obj.jcase == 1
            bmu = obj.X * obj.mu

        elif obj.jcase == 2 || obj.jcase == 3
            bmu = obj.X * obj.mu[2:, ]
            # need to add restr. or unrestr. const later

        elif obj.jcase == 4 || obj.jcase == 5
            bmu = obj.X * obj.mu[3:, ]
            # need to add restr./unr. const & trend later
        endif

    elif obj.k    # no SVEC
        bmu = obj.X * obj.mu    # this was the pre-1.4 handled case
    endif

    # more special treatment of SVEC
    if obj.type == 4
        # add constant
        if obj.jcase > 2      # unrestricted
            bmu = bmu .+  obj.mu[1, ]  # (use broadcasting)

        elif obj.jcase == 2   # restricted
            bmu = bmu .+ (obj.jbeta[obj.n + 1, ] * obj.jalpha')
        endif

        # add trend
        if obj.jcase == 4
            bmu += seq(1, obj.T)' obj.jbeta[obj.n + 1, ] * obj.jalpha'
            # restricted

        elif obj.jcase == 5
            bmu += seq(1, obj.T)' obj.mu[2, ]     # unrestricted
        endif
    endif

    return bmu
end function

#----------------------------------
# These private functions introduced in Aug/Sep 2019
# for general bootstrap

function matrix prepres(matrix E,
                        int boottype[1:4:1] "bootstrap type" \
                        {"resampling", "wildN", "wildR", "wildM"})
    # The input is demeaned (column-wise) only for
    # the resampling (type 1). It isn't done together with the
    # new draws to avoid repeating it many times.

    # (Cannot have 'const matrix E' as gretl versions <2019d would
    #  crash when doing 'return E'.)

    if boottype == 1
        return cdemean(E)
    else
        return E
    endif
end function


function matrix drawbootres(const matrix E,
                            int boottype[1:4:1] "bootstrap type" \
                            {"resampling", "wildN", "wildR", "wildM"},
                            bundle bparams[null] "further inputs" )

    /*
       Construct a new draw of residuals for bootstrapping, where E
       is a Txn matrix.
       E can be original residuals or can be some pre-processed
       input. (See the prepres() function - the pre-processing is
       not done here to avoid doing it repeatedly.)

       Currently boottype can go from 1 to 4:
       1: traditional residual resampling (using gretl's resample())
       2-4: wild bootstrap with the help of a standard normal,
       Rademacher, Mammen distributions respectively

       Other bootstrap types (block, ...) may be added in the future.
       (The E input could be empty then, e.g. for a purely parametric-
       distribution bootstrap. The bundle bparams is intended to be
       used then to specify parameters, in a way that is to be determined.)
    */

    if exists(bparams)
        print "Warning, 'bparams' arg is unused, ignoring."
    endif

    if boottype == 1	# standard
        return resample(E)
    elif boottype > 1 && boottype <= 4
        T = rows(E)
        if boottype == 2
            # Normal
            matrix w = mnormal(T,1)
        elif boottype == 3
            # Rademacher
            matrix w = muniform(T,1) .< 0.5 ? 1 : -1
        elif boottype == 4
            # Mammen
            scalar s5 = sqrt(5)
            scalar p = (0.5/s5) * (s5 + 1)
            matrix w = 0.5 + (muniform(T,1) .< p ? -s5/2 : s5/2)
        endif
        return E .* w
    else
        funcerr "Shouldn't happen"
    endif

end function


function void processCsim(bundle *bobj, matrix *Spar_mat,
                          int i, matrix K,
                          const matrix theta, const bundle m)

    /* This function does the following for i-th iteration:
       - stores basic params (bobj.theta)
       - post-processes the preliminary estimate for C (named K)
       - and stores either that (bobj.C) or A and B (bobj.S1, bobj.S2)
       for use in doIRF
       - stores it/them in vectorized form into Spar_mat
       (if that is wanted for printout)
    */

    n2 = m.n * m.n
    bobj.step = 2
    bobj.theta = theta

    # we don't treat the AB-model specially here (no reason to)
    maybe_flip_columns(m.C, &K)

    if (m.type == 1) || (m.type == 2) || (m.type == 4)
        bobj.C = K	# is used in doIRF()

        if !m.boot_quiet
            Spar_mat[i, 1:n2] = vec(K)'

            /* New Oct 2017: Also bootstrap the long-run matrix if wanted
            Jan 2018: add type 4 */
            if ( m.type < 3 && ( rows(bobj.Rd1l) || bobj.calc_lr ) ) \
                  || m.type == 4
                # (a plain or C model w/ long-run constr, or user switch)
                # long-run mat (C1 comes from get_full_Rd() above
                # (except type 1)):

                matrix C1 = (m.type == 2 || m.type == 4) ? \
                  bobj.C1 : C1mat(bobj.VARpar)
                matrix bobj.lrmat = C1 * bobj.C

                # attach it to the other bootstrap result
                Spar_mat[i, n2+1 : 2*n2] = vec(bobj.lrmat)'
            endif
        endif

    elif m.type == 3
        # (Sven): the following stuff comes from estAB above
        bobj.S1 = bobj.transferAB[1]
        bobj.S2 = bobj.transferAB[2]

        if !m.boot_quiet
            Spar_mat[i,] = vec(bobj.S1)' ~ vec(bobj.S2)'
        endif
    endif

    ### Here the full bias correction block lived before ###

end function

/* ------------------------------------------------------------------- */
/* --- Main bootstrap functions --------------------------------------- */
/* ------------------------------------------------------------------- */

function scalar SVARbootworker(int iter,
                               matrix *bootirfs, matrix *Spar_mat,
                               bundle bobj, const bundle m)
    /*
       In principle it could be avoided to pass m as well as bobj
       since bobj should be a superset, but it makes it clearer which
       parameters stem from the original model...

       Returns the number of failed iterations. Results are stored
       in the pointer matrix args.
    */

    i = 1
    failed = 0
    set loop_maxiter 16384

    /*
       "bootirfs" matrix: will contain the bootstrap results:
       each bootstrap replication on one row; each row contains
       the vectorisation of the complete IRF matrix
    */
    bootirfs = zeros(iter, (m.horizon + 1) * m.n2)

    /* Spar_mat: the result matrix of direct params
       (Spar_mat is only used if !quiet, but always must
       be created as it is passed around.)
    */
    if (m.type > 2) || (rows(m.Rd1l) || m.calc_lr )
        # save either A,B (for type 3) or C and the long-run matrix
        matrix Spar_mat = zeros(iter, 2 * m.n2)

    else # type 1,2,4 and just save the C matrices.
        matrix Spar_mat =  zeros(iter, m.n2)
    endif

    /* constraints-related matrix
       This used to be:
       matrix Rd2 = m.type==3 ? m.Rd0 : m.Rd1l
       but actually it is only used in the type==3 branch
       anymore...
    */
    # matrix Rd2 = m.Rd0 # only works for type==3

    loop while i <= iter --quiet
        bobj.step = 0	# clear previous bootstrap indicator
        /*
           generate bootstrap disturbances: first p rows
           (corresponding to Y0) are 0; for next rows see the
           drawbootres function.
        */
        matrix U = m.bmu[m.p + 1:,] + drawbootres(bobj.innov, m.boottype)
        # (bmu may be zero)

        # generate bootstrap data and store it in bootstrap bobj
        matrix ABCorA = m.reallydoBC ? m.ABC : m.VARpar
        matrix bobj.Y = varsimul(ABCorA, U, m.Y[1: m.p, ])

        /*
           estimate VAR parameters, special treatment VECM/SVEC (type==4)
        */
        if m.type == 4
            vecm_est(&bobj)
        else
            base_est(&bobj)
        endif

        matrix bA = bobj.VARpar  # estimates (first n rows of companion mat)
        matrix bSigma = bobj.Sigma
        matrix theta = m.theta # init original SVAR params
        # (C/A&B apparently, in suitable form...)
        errcode = 0

        ## Full bias correction
        /* (Moved up from below because the new C estimates should be based
           on the bc-ed VARpar version.)
           But note that the bc-ed VARpar only actually enter the new C
           matrix if there are long-run constraints, namely via C1 through
           fullRd.
           Otherwise the new C only depends on Sigma, but we do not update
           Sigma in the full biascorr case. (In theory we could, by
           re-calculating the residuals using the bc-ed VARpar.
           We shouldn't, should we?)
        */

        if m.biascorr == 2 && m.type != 4 # only for non-SVEC
            scalar H = add_and_smash(&bA, m.Psi)

            if ok(H)
                bobj.VARpar = bA
            else
                errcode = 101
            endif
        endif

        /* now re-estimate C, according to model type */

        if m.type == 1 # Cholesky
            matrix K = cholesky(bSigma)

        elif m.type == 2 || m.type == 4 # consolidate the SVEC case here

            matrix fullRd = get_full_Rd(&bobj)
            matrix K = estC(&theta, bSigma, fullRd, null,
              &errcode, m.optmeth, 0)

        elif m.type == 3 # "AB"
            matrices transferAB = array(2)
            # new: get A,B instead of re-calc'ing it below
            matrix K = estAB(&theta, bSigma, m.Rd0, m.Rd1, null, \
              &errcode, m.optmeth, 0, &transferAB)
            matrices bobj.transferAB = transferAB
        endif

        ## Process and store the simulated C (or A, B) results
        if !errcode && rows(K) == m.n
            processCsim(&bobj, &Spar_mat, i,K,theta,m)
            doIRF(&bobj)
            bootirfs[i,] = vec(bobj.IRFs)'
            i++
        else
            failed++
            outfile stderr --write
            printf "Iter %4d failed (error code = %d)\n", i, errcode
            outfile --close
        endif
    endloop

    return failed
end function

#----
function scalar isMPIok(const bundle m)
	scalar mpiok = $sysinfo.mpi	# Is MPI present at all? 
	mpiok = mpiok && m.nboot > 1000	# do no trivial stuff

	if inbundle(m, "forcempi")	# user override
		mpiok = m.forcempi
	endif

	return mpiok 
end function 

#----


function scalar SVAR_boot(bundle *m,
                          int rep[0::2000] "bootstrap iterations",
                          scalar alpha[0:1:0.9] "CI coverage",
                          bool quiet[1],
                          string btypestr[null] "bootstrap type",
                          int biascorr[-1:2:-1] "bias correction (non-SVEC)")

    /* strBtype: can be "resample" / "resampling",
      "wildN"/"wild", "wildR", "wildM"

     The default value for biascorr of -1 means:
      Do not override the previous setting.
	*/

    ## Copy some params and choices into original model
    m.nboot = rep
    m.boot_alpha = alpha
    m.boot_quiet = quiet

    # Bootstrap type choice (if different from default)
    if exists(btypestr)
        temp = boottypecode(btypestr)
        if temp == 0
            print "Warning: ignoring unrecognized bootstrap type choice."
        else
            m.boottype = temp
        endif
    endif

    /* ------- Bias-correction related stuff ---------------*/
    # Bias correction choice
    if biascorr > -1
        m.biascorr = biascorr
    endif

    # define default for bias correction iterations
    if m.biascorr && !inbundle(m, "BCiter")
        m.BCiter = 1024
    endif

    # And see if bias corr really applies (not available w/unit roots)
    m.reallydoBC = (m.type != 4) && m.biascorr

    ### Various needed stuff
    m.n2 = m.n * m.n
    if m.type == 3 # AB
        matrix bmA bmB # needed as memory for transfer
    elif m.type == 4
        matrix J = zeros(m.n - m.crank, m.crank) | I(m.crank)
    endif
    # not needed anymore: matrix start = m.Y[1:p, ] # Y0

    # disentangle determ/exog:
    matrix m.bmu = calc_bmu(m)

    bundle bobj = m       # store a copy of the model for bootstrap

    # >>>>> This is the place where the unused if-block lived <<<<<
    # >>>>> (moved to the end of this file for future reference) <<

    /* Prepare the residuals
       (must come before the bias correction since that
       uses the innovations)
    */
    matrix bobj.innov = prepres(m.E, m.boottype)

    ## Do the bias correction pre-step if applicable
    if m.reallydoBC
        matrix mtemp = {}	# was Psi
        # pass bobj, not m, because of innov! :
        matrix m.ABC = bias_correction(bobj, m.bmu, &mtemp)
        matrix m.Psi = mtemp
    endif

    printf "\nBootstrapping model (%d iterations)\n", m.nboot
    printf "Bootstrap type: %s\n", btypestring(m.boottype)
    printf "Bias correction: %s\n\n", BCstring(m.biascorr)


    ########### Main bootstrap work ###########

	if isMPIok(m)
		printf " Running parallel bootstrap (MPI), "	
		P = xmin(4, $sysinfo.nproc)
		printf "size %d\n", P
		flush

		# write out the bundles to load them back inside MPI
		# (hardcoded names) 
		errm = bwrite(m, "SVAR_MPI_m.gz", 1)
		errb = bwrite(bobj, "SVAR_MPI_bobj.gz", 1)
		if errm + errb > 0
			print "Writing bundles for MPI failed (parallel bootstrap)."
			print "Can use: <ModelBundle>.mpiforce = 0"
			print " before calling SVAR_boot to switch off MPI usage."
			funcerr "error writing bundles for MPI"
		endif
		

		mpi --send-functions
			# Define needed objects for bootstrap
    		matrix bootirfs, Spar_mat
			bundle mpim, mpibobj

			# Retrieve ingredients
			if $mpirank == 0
				mpim = bread("SVAR_MPI_m.gz", 1)
				mpibobj = bread("SVAR_MPI_bobj.gz", 1)
				
				# debug:
				# print "read the bundles alright"
			endif

			mpibcast(&mpim)
			mpibcast(&mpibobj)
			localiter = floor(mpim.nboot / $mpisize)
			failed = SVARbootworker(localiter, &bootirfs, &Spar_mat, mpibobj,mpim)

			# combine the results (stacking)
			mpireduce(&bootirfs, vcat)
			mpireduce(&Spar_mat, vcat)
			mpireduce(&failed, sum)
			mpireduce(&localiter, sum)

			# Transfer results (binary for speed)
			if $mpirank == 0
				mwrite({localiter, failed}, "SVAR_MPI_iterfail.mat", 1)
				mwrite(bootirfs, "SVAR_MPI_bootirfs.bin", 1)
				mwrite(Spar_mat, "SVAR_MPI_Spar_mat.bin", 1)
			endif			
		
		end mpi --np=P --omp-threads=1

		# Read in the MPI results
		matrix iterfail = mread("SVAR_MPI_iterfail.mat", 1)
		m.nboot = iterfail[1]	# could be slightly less (rounding)
		failed = iterfail[2]
		matrix bootirfs = mread("SVAR_MPI_bootirfs.bin", 1)
		matrix Spar_mat = mread("SVAR_MPI_Spar_mat.bin", 1)

		# TODO: clean up all the temp files in the dotdir?

	else
		# (no MPI support, just do the normal sequential thing)
		flush
		# Define needed objects for bootstrap
    	matrix bootirfs, Spar_mat
    	failed = SVARbootworker(m.nboot, &bootirfs, &Spar_mat, bobj,m)
	endif

    ############ end main bootstrap ###############################

    if !quiet
        boot_printout(m.type, m.n, m.nboot, failed, Spar_mat)
    endif

    # quantiles of bootstrapped IRFs used in graphs
    q_alpha = 0.5 * (1 - m.boot_alpha)	# changed in v1.5
    matrix locb = quantile(bootirfs, q_alpha)
    matrix hicb = quantile(bootirfs, 1 - q_alpha)
    matrix mdn  = quantile(bootirfs, 0.5)

    bundle bootdata = null
    bootdata.rep   = m.nboot         # no of replications
    bootdata.alpha = m.boot_alpha    # coverage
    bootdata.biascorr  = m.biascorr  # type of bias correction
    matrix bootdata.lo_cb = mshape(locb, m.horizon + 1, m.n2) # lower
    matrix bootdata.hi_cb = mshape(hicb, m.horizon + 1, m.n2) # upper
    matrix bootdata.mdns  = mshape(mdn, m.horizon + 1, m.n2)	# medians

    bundle m.bootdata = bootdata
    return failed
end function

# [This is the code block that was in SVAR_boot, see there]: 
# -------------------------------
# FIXME: Why is this if-block needed??? Where is it used?
/* Partial answer:
   'sel' is currently calculated in doIRF (?), inside the
   bootstrap loop. It'd be slightly more efficient to pre-
   calculate it here, e.g. storing it in m.cumsel.
   However, the cumulated IRF would also be needed when no
   bootstrap is done. So it seems 'sel' must be calc'ed
   somewhere else...
*/
#     if m.ncumul > 0
#         matrix to_cum = m.cumul
#         matrix tmp = zeros(n, n)
#         tmp[to_cum,] = 1
#         sel = selifr(transp(seq(1, n2)), vec(tmp))	# was: n*n
#     endif
# ---------------------------------
